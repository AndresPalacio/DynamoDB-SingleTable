<h1 id="dynamodb-singletable">DynamoDB SingleTable</h1>
<p>Python DynamoDB interface, specialized in single-table design.
DynamoDB is high-performance serverless NoSQL, but difficult to disign
tables.</p>
<p>Single-table design needs only single table, and few GSIs (Global
Secondary Indexes). It makes effective and easy to manage your whole
data models for single service.</p>
<h2 id="getting-started">Getting Started</h2>
<h3 id="init-table">Init Table</h3>
<pre class="python"><code>from ddb_single import Table

table = Table(
    table_name=&quot;sample&quot;,
    endpoint_url=&quot;http://localhost:8000&quot;,
)
table.init()</code></pre>
<h3 id="data-models">Data Models</h3>
<p>Each model has al least 3 keys - primary_key … Hash key for single
item. default: <code>pk: {__model_name__}_{uuid}</code> - seconday_key …
Range key for item. default: <code>sk: {__model_name__}_item</code> -
unique_key … key to identify the item is the same. Mainly used to update
item.</p>
<p>And you can set <code>serch_key</code> to enable search via GSI</p>
<pre class="python"><code>from ddb_single import BaseModel, DBField, FieldType

class User(BaseModel):
    __table__=table
    __model_name__ = &quot;user&quot;
    name = DBField(unique_key=True)
    email = DBField(search_key=True)
    age = DBField(type=FieldType.NUMBER, search_key=True)
    description=DBField()</code></pre>
<h2 id="usage">Usage</h2>
<p>need “Qurey” object for CRUD - <code>query.model(foo).create</code> -
<code>query.model(foo).get</code> - <code>query.model(foo).search</code>
- <code>query.model(foo).update</code> -
<code>query.model(foo).delete</code></p>
<pre class="python"><code>from ddb_single import Query
query = Query(table)</code></pre>
<h3 id="create-item">Create Item</h3>
<p>If the item with same value of <code>unique_key</code> already exist,
exist item is updated.</p>
<pre class="python"><code>user = User(name=&quot;John&quot;, email=&quot;john@example.com&quot;, description=&quot;test&quot;)
query.model(user).create()</code></pre>
<p>Then, multible items added.</p>
<table>
<thead>
<tr class="header">
<th>pk</th>
<th>sk</th>
<th>data</th>
<th>name</th>
<th>email</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>user_xxxx</td>
<td>user_item</td>
<td></td>
<td>John</td>
<td>john@example.com</td>
<td>test</td>
</tr>
<tr class="even">
<td>user_xxxx</td>
<td>search_user_name</td>
<td>John</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>user_xxxx</td>
<td>search_user_email</td>
<td>new-john@example.com</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>In addition to main item (sk=<code>user_item</code>), multiple item
(sk=<code>search_{__model_name__}_{field_name}</code>) added to table.
Those “search items” are used to search</p>
<p>The GSI <code>DataSearchIndex</code> is used to get “search items” to
extract target’s pk. Then, <code>batch_get</code> items by pk.</p>
<table>
<thead>
<tr class="header">
<th>sk = hash</th>
<th>data = range</th>
<th>pk</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>search_user_name</td>
<td>John</td>
<td>user_xxxx</td>
</tr>
<tr class="even">
<td>search_user_email</td>
<td>new-john@example.com</td>
<td>user_xxxx</td>
</tr>
</tbody>
</table>
<h3 id="search-items">Search Items</h3>
<pre class="python"><code>user = query.model(User).search(User.name.eq(&quot;John&quot;))
print(user)
# -&gt; [{&quot;pk&quot;:&quot;user_xxxx&quot;, &quot;sk&quot;:&quot;user_item&quot;, &quot;name&quot;:&quot;John&quot;, &quot;email&quot;:&quot;john@example.com&quot;}]</code></pre>
<p><code>pk_only=True</code> to extract pk without
<code>batch_get</code></p>
<pre class="python"><code>user_pks = query.model(User).search(User.name.eq(&quot;John&quot;), pk_only=True)
print(user_pks)
# -&gt; [&quot;user_xxxx&quot;]</code></pre>
<h3 id="get-single-item">Get single item</h3>
<p><code>get(pk)</code> to get single item.</p>
<pre><code>user = query.model(User).get(&quot;user_xxxx&quot;)
print(user)
# -&gt; {&quot;pk&quot;:&quot;user_xxxx&quot;, &quot;sk&quot;:&quot;user_item&quot;, &quot;name&quot;:&quot;John&quot;, &quot;email&quot;:&quot;john@example.com&quot;}</code></pre>
<p><code>get_by_unique</code> to get item by <code>unique_key</code></p>
<pre class="python"><code>user = query.model(User).get_by_unique(&quot;John&quot;)
print(user)
# -&gt; {&quot;pk&quot;:&quot;user_xxxx&quot;, &quot;sk&quot;:&quot;user_item&quot;, &quot;name&quot;:&quot;John&quot;, &quot;email&quot;:&quot;john@example.com&quot;}</code></pre>
<p><code>pk_only=True</code> option in <code>get_by_unique</code> to get
<code>primary key</code> without <code>get_item</code></p>
<pre class="python"><code>pk = query.model(User).get_by_unique(&quot;John&quot;)
print(pk)
# -&gt; &quot;user_xxxx&quot;</code></pre>
<h3 id="update-item">Update Item</h3>
<pre class="python"><code>user = query.model(User).search(User.email.eq(&quot;john@example.com&quot;))
new_user = User(**user[0])
new_user.email = &quot;new-john@example.com&quot;
query.model(new_user).update()</code></pre>
<p>Or use unique value to detect exist item.</p>
<pre class="python"><code>new_user = User(name=&quot;John&quot;, email=&quot;new-john@example.com&quot;)
query.model(new_user).update()</code></pre>
<p>Then, tha value of “main item” and “seach item” changed</p>
<table>
<thead>
<tr class="header">
<th>pk</th>
<th>sk</th>
<th>data</th>
<th>name</th>
<th>email</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>user_xxxx</td>
<td>user_item</td>
<td></td>
<td>John</td>
<td>new-john@example.com</td>
<td>test</td>
</tr>
<tr class="even">
<td>user_xxxx</td>
<td>search_user_name</td>
<td>John</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>user_xxxx</td>
<td>search_user_email</td>
<td>new-john@example.com</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="delete-item">Delete Item</h3>
<pre><code>user = query.model(User).search(User.email.eq(&quot;new-john@example.com&quot;))
query.model(user[0]).delete()</code></pre>
<p><code>primary key</code> to detect exist item.</p>
<pre><code>query.model(User).delete_by_pk(&quot;user_xxxx&quot;)</code></pre>
<p>or <code>unique key</code></p>
<pre><code>query.model(User).delete_by_unique(&quot;John&quot;)</code></pre>
<h2 id="batch-writer">Batch Writer</h2>
<p><code>table.batch_writer()</code> to create/update/delete multible
items - <code>query.model(foo).create(batch=batch)</code> -
<code>query.model(foo).update(batch=batch)</code> -
<code>query.model(foo).delete(batch=batch)</code></p>
<h3 id="batch-create">Batch Create</h3>
<pre class="python"><code>with table.batch_writer() as batch:
    for i in range(3):
        user = User(name=f&quot;test{i}&quot;, age=i+10)
        query.model(user).create(batch=batch)
res = query.model(User).search(User.name.begins_with(&quot;test&quot;))
print([(r[&quot;name&quot;], r[&quot;age&quot;]) for r in res])
# -&gt; [(&quot;test0&quot;, 10), (&quot;test1&quot;, 11), (&quot;test2&quot;, 12)]</code></pre>
<h3 id="batch-update">Batch Update</h3>
<pre class="python"><code>with table.batch_writer() as batch:
    for i in range(3):
        user = User(name=f&quot;test{i}&quot;, age=i+20)
        query.model(user).update(batch=batch)
res = query.model(User).search(User.name.begins_with(&quot;test&quot;))
print([(r[&quot;name&quot;], r[&quot;age&quot;]) for r in res])
# -&gt; [(&quot;test0&quot;, 20), (&quot;test1&quot;, 21), (&quot;test2&quot;, 22)]</code></pre>
<h3 id="batch-delete">Batch Delete</h3>
<pre class="python"><code>pks = query.model(User).search(User.name.begins_with(&quot;test&quot;), pk_only=True)
with table.batch_writer() as batch:
    for pk in pks:
        query.model(user).delete_by_pk(pk, batch=batch)
res = query.model(User).search(User.name.begins_with(&quot;test&quot;))
print(res)
# -&gt; []</code></pre>
<h2 id="relationship">Relationship</h2>
<h3 id="create-model">Create Model</h3>
<p>You can sat relationns to other models
<code>relation=BaseModel</code> to set relation.</p>
<pre class="python"><code>class BlogPost(BaseModel):
    __model_name__ = &quot;blogpost&quot;
    __table__=table
    name = DBField(unique_key=True)
    content = DBField()
    author = DBField(reletion=User)</code></pre>
<h3 id="create-item-1">Create Item</h3>
<pre class="python"><code>blogpost = BlogPost(
    name=&quot;Hello&quot;,
    content=&quot;Hello world&quot;,
    author=self.user
)
query.model(blogpost).create()</code></pre>
<p>Then, tha value “reletion item” added</p>
<table>
<thead>
<tr class="header">
<th>pk</th>
<th>sk</th>
<th>data</th>
<th>name</th>
<th>author</th>
<th>content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>user_xxxx</td>
<td>user_item</td>
<td></td>
<td>John</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>user_xxxx</td>
<td>search_user_name</td>
<td>John</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>blogpost_xxxx</td>
<td>blogpost_item</td>
<td></td>
<td>Hello</td>
<td>John</td>
<td>Hello world</td>
</tr>
<tr class="even">
<td>blogpost_xxxx</td>
<td>search_blogpost_title</td>
<td>Hello</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>blogpost_xxxx</td>
<td>rel_user_xxxx</td>
<td>author</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>In addition to main item (sk=<code>blogpost_item</code>), relation
item (sk=<code>rel_{primary_key}</code>) added to table. The GSI
<code>DataSearchIndex</code> is used to get “relation items” to extract
target’s pk. Then, <code>batch_get</code> items by pk.</p>
<table>
<thead>
<tr class="header">
<th>sk = hash</th>
<th>data = range</th>
<th>pk</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>rel_user_xxxx</td>
<td>author</td>
<td>blogpost_xxxx</td>
</tr>
</tbody>
</table>
<h3 id="search-relations">Search Relations</h3>
<p><code>get_relation(model=Basemodel)</code> to search relations</p>
<pre class="python"><code>blogpost = query.model(BlogPost).get_by_unique(&quot;Hello&quot;)
blogpost = BlogPost(**blogpost)

user = query.model(blogpost).get_relation(model=User)
print(user)
# -&gt; [{&quot;pk&quot;:&quot;user_xxxx&quot;, &quot;sk&quot;:&quot;user_item&quot;, &quot;name&quot;:&quot;John&quot;}]</code></pre>
<p>Also <code>get_relation(field=DBField)</code> to specify field</p>
<pre class="python"><code>user = query.model(blogpost).get_relation(field=BlogPost.author)
print(user)
# -&gt; [{&quot;pk&quot;:&quot;user_xxxx&quot;, &quot;sk&quot;:&quot;user_item&quot;, &quot;name&quot;:&quot;John&quot;}]</code></pre>
<h3 id="search-reference">Search Reference</h3>
<p>In this library, “reference” is antonym to relation</p>
<p><code>get_reference(model=Basemodel)</code> to search items related
to the item</p>
<pre class="python"><code>user = query.model(User).get_by_unique(&quot;John&quot;)
user = User(**blogpost)

blogpost = query.model(blogpost).get_reference(model=BlogPost)
print(blogpost)
# -&gt; [{&quot;pk&quot;:&quot;blogpost_xxxx&quot;, &quot;sk&quot;:&quot;blogpost_item&quot;, &quot;name&quot;:&quot;Hello&quot;}]</code></pre>
<p>Also <code>get_reference(field=DBField)</code> to specify field</p>
<pre class="python"><code>blogpost = query.model(user).get_reference(field=BlogPost.author)
print(blogpost)
# -&gt; [{&quot;pk&quot;:&quot;blogpost_xxxx&quot;, &quot;sk&quot;:&quot;blogpost_item&quot;, &quot;name&quot;:&quot;Hello&quot;}]</code></pre>
<h3 id="update-relation">Update Relation</h3>
<p>If relation key’s value changed, relationship also changed.</p>
<pre class="python"><code>new_user = User(name=&quot;Michael&quot;)
blogpost = query.model(BlogPost).get_by_unique(&quot;Hello&quot;)
blogpost[&quot;author&quot;] = new_user
blogpost = BlogPost(**blogpost)

query.model(blogpost).update()</code></pre>
<p>Then, “reletion item” changed</p>
<table>
<thead>
<tr class="header">
<th>pk</th>
<th>sk</th>
<th>data</th>
<th>name</th>
<th>author</th>
<th>content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>user_xxxx</td>
<td>user_item</td>
<td></td>
<td>John</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>user_xxxx</td>
<td>search_user_name</td>
<td>John</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>user_yyyy</td>
<td>user_item</td>
<td></td>
<td>Michael</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>user_yyyy</td>
<td>search_user_name</td>
<td>Michael</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>blogpost_xxxx</td>
<td>blogpost_item</td>
<td></td>
<td>Hello</td>
<td>Michael</td>
<td>Hello world</td>
</tr>
<tr class="even">
<td>blogpost_xxxx</td>
<td>search_blogpost_title</td>
<td>Hello</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>blogpost_xxxx</td>
<td>rel_user_yyyy</td>
<td>author</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="delete-relation">Delete Relation</h3>
<p>If related item deleted, relationship also deleted</p>
<pre class="python"><code>query.model(user).delete_by_unique(&quot;Michael&quot;)</code></pre>
<p>Then, “reletion item” deleted. But main item’s value is not
chenged.</p>
<table>
<thead>
<tr class="header">
<th>pk</th>
<th>sk</th>
<th>data</th>
<th>name</th>
<th>author</th>
<th>content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>user_xxxx</td>
<td>user_item</td>
<td></td>
<td>John</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>user_xxxx</td>
<td>search_user_name</td>
<td>John</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>blogpost_xxxx</td>
<td>blogpost_item</td>
<td></td>
<td>Hello</td>
<td>Michael</td>
<td>Hello world</td>
</tr>
<tr class="even">
<td>blogpost_xxxx</td>
<td>search_blogpost_title</td>
<td>Hello</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>